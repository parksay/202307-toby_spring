package basics.tobyspring6.chapter63;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Method;

public class ReflectionTest632 {

    @Test
    public void invokeTest() throws Exception {
        //
        String name = "spring";

        // length()
        Assertions.assertEquals(name.length(), 6);

        // invoke() > length()
        Method lengthMethod = String.class.getMethod("length");
        int resultInvoke = (int) lengthMethod.invoke(name);
        Assertions.assertEquals(resultInvoke, 6);

        // charAt()
        Assertions.assertEquals(name.charAt(0), (Character) 's');
        // (Character) 's' // 문자열을 char 로 변환

        // invoke() > charAt()
        Method charAtMethod = String.class.getMethod("charAt", int.class);
        Assertions.assertEquals(Character.toString((Character) charAtMethod.invoke(name, 0)), "s");
        Assertions.assertEquals(String.valueOf(charAtMethod.invoke(name, 0)), "s");
        // char 를 string 으로 변환
        // Character.toString(myChar);
        // String.valueOf(myChar);

    }
}

//// p.429 - chapter6.3.1
//프록시 패턴과 데코레이터 패턴에 대해 알아보자.
//우리가 앞에서 만든 UserService 를 보자.
//UserService 안에 upgradeLevel() 기능을 그 자체로 잘 작동하고 있지.
//upgradeLevel() 만 가지고도 테스트가 돼.
//근데 그 위에 트랜잭션 기능을 덧붙이고 싶은 거야.
//그래서 어떤 방법을 썼느냐?
//중간에 허수아비 하나를 세워뒀지.
//인터페이스로 구현하고 인터페이스로 부르는 거야.
//기능을 추가하고 싶은 대상은 UserService 야.
//얘를 인터페이스로 바꾸고 구현 클래스는 따로 만들어 뒀어.
//그리고 똑같은 인터페이스로 구현한 클래스를 하나 더 만들고, 그 안에 부가 기능을 넣었어.
//그럼 이제 UserService 를 구현한 클래스가 두 개가 됐지.
//원래 있던 핵심 기능은 UserServiceImpl 에 들어가 있고, 트랜잭션 추가 기능은 UserServiceTx 에 들어가 있어.
//근데 클라이언트는 지금 인터페이스로 불러다가 쓰고 있거든.
//내가 불러다 쓰는 애가 어떤 구현체인지 모르거든.
//바로 이걸 이용하는 거지.
//클라이언트가 추가 기능이 있는 클래스를 불러다 써.
//그럼 추가 기능이 있는 쪽에서는 자기가 기능 추가할 거부터 다 실행하고 그 다음에 핵심 기능 꺼 불러줘.
//이렇게 마치 클라이언트 앞에서 자기가 실제로 실행되는 오브젝트인 것처럼 위장하는 오브젝트를 '프록시'라고 불러.
//클라이언트와 그 클라이언트가 사용하는 실제 대상 사이에 다른 친구를 끼워 넣는 방법.
//실제로 핵심 기능을 가지고 있는 애를 '타겟(target)' 또는 '실체(real subject)' 라고 불러.
//// 프록시 패턴과 데코레이터 패턴 > 프록시 패턴
//클라이언트와 타겟 사이에 프록시를 끼워넣는 목적은 크게 두 가지로 나눠.
//첫째는 클라이언트가 타겟에 접근하는 방법을 제어하기 위함.
//둘째는 타겟에 이런 저런 부가 기능을 추가하기 위함.
//여기서 첫째 목적으로 사용했을 때는 '프록시 패턴'이라고 부르고
//둘째 목적으로 사용했을 때는 '데코레이터 패턴'이라고 불러.
//먼저 프록시 패턴을 보자.
//프록시 패턴은 타겟에 접근하는 방법을 제어하는 목적이라고 했지.
//이게 무슨 소리냐?
//예를 들어서 클라이언트가 어떤 원격 오브젝트에 의존하고 있어.
//이럴 때 클라이언트와 원격 오브젝트 사이에 프록시로 로컬 오브젝트를 세워둘 수 있어.
//그럼 클라이언트 입장에서는 마치 로컬에 존재하는 오브젝트를 사용하는 것처럼 원격 오브젝트를 쓸 수 있지.
//또는 프록시 패턴을 사용하는 다른 예시로 오브젝트 지연 생성이 있어.
//타겟 오브젝트를 생성하는 데에 리소스가 많이 들거나 복잡하거나 당장 필요하지 않다면 꼭 필요한 시점까지 오브젝트 생성을 미루는 게 좋겠지.
//그런데 타겟 오브젝트의 레퍼런스가 미리 필요한 경우도 있어.
//그럴 때는 일단 프록시를 먼저 넘겨주는 거야.
//일단 그거부터 손에 쥐어주고 레퍼런스만 갖고 있으라고 해.
//그러다가 어떤 메소드를 실행하면 그때가서 진짜 오브젝트를 생성하는 거지.
//또는 어떤 계층까지는 읽기랑 쓰기 모두 가능하게 하다가 어느 계층 넘어가면서부터는 읽기만 가능하게 접근을 막을 수도 있고.
//Collections 의 unmodifiableCollection() 이 바로 그런 경우.
//이렇게 프록시 패턴은 타겟의 기능 자체에는 영향을 주지 않지만 접근을 제어하는 경우에 써.
//덧붙임) 여기서 쓰는 '프록시 패턴'이랑 '프록시'랑은 다른 개념.
//프록시는 그냥 클라이언트랑 타겟 사이에 끼워넣는 다른 요소 자체를 프록시라고 불러.
//프록시 패턴은 그러한 프록시를 응용해서 어떤 패턴이나 틀을 정형화한 거고.
//// 프록시 패턴과 데코레이터 패턴 > 데코레이터 패턴
//프록시를 사용하는 첫 번째 목적으로 '프록시 패턴'이 뭔지 알아봤어.
//다음은 프록시를 사용하는 두 번째 목적 '데코레이터 패턴'을 알아보자.
//똑같은 인터페이스를 구현한 클래스가 여러 개 있다고 해보자.
//다 각자 어떤 추가 기능을 가지고 있고, 실제로 동작해야 하는 부분에서는 다른 구현체한테 떠넘겨.
//얘도 어쩌구 어쩌구 하다가 a.add(); 쟤도 저쩌구 저쩌구 하다가 b.add(); ..
//근데 웃긴 건 다들 자기가 누구를 불러다 쓸지 몰라.
//자기 기능을 누구한테 위임하게 될지 몰라.
//왜냐하면 다들 인터페이스로 받아서 인터페이스의 어떤 메소드를 실행하는 거거든.
//그 인터페이스 안에 어떤 구현체가 들어올지는 자기도 몰라.
//이렇게 실제 알맹이는 변하지 않는데, 그 위에 포장지를 이것 저것 바꿔 끼거나 장신구를 그때 그때 바꿔 낄 수가 있어.
//이런 패턴을 데코레이터 패턴이라고 해.
//핵심 기능은 따로 있고, 다른 추가 기능들을 프록시로 만들어 두는 거지.
//예를 들어서 로그를 출력하는 기능이 핵심 기능이라고 해보자.
//거기에 이것 저것 계속 붙이는 거야.
//라인 넘버를 붙여줄 수도 있고, 특정 단어에 색깔을 입힐 수도 있고, 줄 간격을 조정할 수도 있고....
//어차피 모두 같은 인터페이스를 구현하고 있기 때문에 어디로부터 불려가서 어디한테로 넘겨줄지 몰라.
//마치 기차 레일을 퍼즐처럼 조립하는 것과 같지.
//예시는 자바 IO 패키지의 InputStream 과 OutputStream 이야.
//InputStream 이라는 인터페이스가 있는데, 그 인터페이스를 파일을 읽을 수 있도록 구현한 FileInputStream 이 있고, 그 파일 읽기 기능에 Buffer 읽기 기능을 추가하는 코드.
//InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));
//이렇게 데코레이터 패턴은 타겟의 코드 자체는 손대지 않으면서, 클라이언트가 부르는 방법도 그대로 두면서, 새로운 기능들을 그때 그때 덧붙여서 사용할 수 있는 패턴이야.
////
//// p.435 - chapter 6.3.2
//프록시라는 녀석 안에는 결구 두 가지 기능이 있는 거지.
//첫째, 클라이언트가 어떤 메소드를 호출하면 타겟 오브젝트한테 똑같은 메소드 호출을 떠넘기는 것.
//둘째, 클라이언트가 호출한 메소드를 타겟 오브젝트가 실행하기 전에 어떤 부가 기능을 수행하는 것.
//근데 이렇게 좋은 프록시를 만들기가 또 귀찮아져.
//프로그래머들 진짜 귀차니즘 걸려서 밥은 어떻게 먹고 사냐.
//반복되거나 중복되는 거 못참지.
//근데 또 이게 프록시 만드는 일이 중복되거나 반복되는 게 많거든.
//첫째로, 비어 있는 메소드라도 일일이 다 구현해두어야 해.
//테스트 할 때 목 오브젝트 만들 때도 그랬지.
//똑같은 인터페이스를 구현해놔야 한다고 했지.
//아무 기능이 없어도 그냥 타겟한테 떠넘기기 위한 구현이라도 일일이 구현해야 해.
//인터페이스를 구현해 놓은 구현체니까 어쩔 수가 없어.
//근데 문제는, 인터페이스 구조가 바뀌면,.,.?
//타겟 하나에도 기능을 4,5개 씩 붙일 수도 있는데 그거 일일이 찾아가서 고쳐야 해.
//둘째로, 중복이 발생하는 경우가 많아.
//우리가 만든 upgradeLevels() 만 봐도 그렇지.
//트랜잭션 기능이 어디 upgradeLevels() 만 들어가겠어?
//add() 에도 새로운 기능이 추가되면 또 트랜잭션 기능 넣어야 하고,
//delete() 에도, get() 에도....
//다른 DAO 에서도 중복될 가능성이 있지.
//이렇게 프록시로 만드는 기능은 애초에 중복될 가능성이 큰 게 많아.
//// 리플렉션
//그래서 이런 기능을 해결하는 방법이 있어.
//클래스의 메타 정보들을 활용하는 방법인데.
//MyClass.class 또는 myObject.getClass() 이렇게 하면 클래스 타입의 오브젝트를 받아올 수 있어.
//자바의 모든 클래스는 그 클래스 자체의 구성 정보가 들어 있는 'Class' 라는 타입의 오브젝트를 들고 있거든.
//이 클래스 오브젝트를 이용하면 이 클래스가 어떤 클래스를 상속했는지, 어떤 인터페이스를 구현했는지,
//이 클래스 안에 어떤 메소드들이 있고 그 메소드들은 어떤 파라미터를 받는지, 각 메소드의 리턴 타입은 뭔지 등등
//이런 각종 메타 정보들을 얻을 수가 있어.
//java.lang.reflect 패키지의 자바 문서 참고해 보길.
//myClass.getMethod("methodName"); 하면 메소드 오브젝트 받아올 수 있고 그 메소드 오브젝트에 myMethod.invoke() 하면 실행도 할 수 있어.


