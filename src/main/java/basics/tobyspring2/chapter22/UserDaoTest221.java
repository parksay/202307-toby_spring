package basics.tobyspring2.chapter22;

import basics.tobyspring1.chapter18.User111;
import basics.tobyspring1.chapter18.UserDao184;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.GenericXmlApplicationContext;

import java.sql.SQLException;

public class UserDaoTest221 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {

        // 오브젝트 생성
        ApplicationContext context = new GenericXmlApplicationContext("chapter18/applicationContext184.xml");
        UserDao184 dao = context.getBean("userDao", UserDao184.class);
        User111 user = new User111();
        user.setId("test221");
        user.setName("테스트221");
        user.setPassword("myTest");
        //
        dao.add(user);
        //
        System.out.println(user.getId() + "등록 성공");
        //
        User111 user2 = dao.get(user.getId());
        //
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        System.out.println(user2.getId() + "조회 성공");
        
        // 테스트 실패 시
        if(!user.getName().equals(user2.getName())) {
            System.out.println("테스트 실패 (name)");
        } else if(!user.getPassword().equals(user2.getPassword())) {
            System.out.println("테스트 실패 (password)");
        } else {
        // 테스트 성공 시
            System.out.println("조회 테스트 성공");
        }

    }
}

//p.146
//chapter2.2.1 - 테스트의 중요성
//스프링의 주요 기능을 최소한으로 꼽는다고 하면 첫째가 지금까지 배운 IoC/DI 컨테이너
//그리고 둘째가 바로 테스트 기능이다.
//그만큼 스프링 개발자라고 하면 테스트를 가까이 두고 자유자재로 다룰 줄 알아야 한다.
//스프링이 제공하는 테스트 기능을 사용하지 않는다면 스프링의 절반을 포기하는 것이다.
//그만큼 테스트란 기본적인 기능이고, 기본적이라는 건 중요하다는 뜻이다.
//소프트웨어는 항상 변한다고 했다.
//변화를 멈추는 때는 그 소프트웨어가 폐기되고 더 이상 운영되지 않을 때뿐이다.
//변화한다는 점에 불만을 가질 게 아니라, 변화에 잘 대비해야 한다.
//스프링이 이러한 변화를 대비하는 방법은 크게 두 가지가 있다.
//하나는 자바라는 객체지향 언어의 언어를 살리는 것이다.
//수정에는 닫혀 있고 확장에는 열려 있는 개방폐쇄원칙에 따라 개발하면 변화가 발생해도 최소한의 수정으로 대처할 수 있다.
//다른 하나가 바로 이제부터 배울 테스트다.
//요구 사항이나 기능에 변화가 일어나고 나면 코드를 수정해야 한다.
//수정이 완료 되고 나면 먼저 확인해야 할 부분이 있다.
//일단 지금까지 잘 되던 기능들이 그대로 잘 되어야 한다는 점이다.
//새로 개발한 기능이 기존에 되던 기능에 영향을 주어서 되던 게 안 되면 곤란하다.
//그럼 이미 잘 운영되고 있던 서비스를 또 다시 처음부터 시작해서 끝까지 테스트해볼 것인가?
//그런데 처음에 기능을 개발할 때부터 각 기능마다 테스트 코드를 짜 두었다고 해 보자.
//그럼 수정 사항이 발생했을 때 수정을 마치고 테스트만 돌려 보면 된다.
//기존에 되던 기능이 잘 되는지 한 번에 확인할 수 있다.
//개발하는 중에는 객체지향 언어의 특징을 살려서 변화에 대비하고,
//개발이 끝나고 나서는 테스트를 활용하여 변화에 적응한다.
//스프링이 변화에 대비하는 방법이다.
//그럼 스프링이 테스트 기능을 어떻게 지원해주는지는 차차 알아보기로 하고 일단은 테스트의 중요성을 알아보자.
//테스트는 어떻게 해야 하는가?
//첫째로, 잘게 나눌수록 좋다.
//둘째로, 그때그때 바로 할수록 좋다.
//셋째로, 자동화할수록 좋다.
//첫째로, 테스트는 기능을 잘게 나누어서 테스트할수록 좋다.
//어느 기능에서 문제가 일어난 건지 명확하게 확인할 수 있기 때문이다.
//예를 들어 웹 화면 띄워놓고 테스트 하려고 하면 어떨까?
//화면에서 데이터 가공하고, 가공한 데이터 서버로 보내고, 서버에서 받아서 로직 거치고, 디비 접속해서 데이터 저장하고,
//저장한 데이터 다시 불러오고, 불러온 데이터 서비스 로직 거치고, 서비스 로직에서 화면으로 다시 던져주고...
//내가 테스트 하고 싶은 거는 그냥 디비 잘 접속해서 데이터가 잘 들어가는지, 그거 보고 싶은 거였다.
//근데 그 과정에서 관여하고 있는 기술들이 너무 많아지면서 에러가 나도 어디서 났는지 알기 어렵다.
//디비 접근 기능 하나 테스트하려고 서버까지 띄우고 화면까지 만들고 배보다 배꼽이 더 커진다.
//그냥 디비 접근 클래스만 오브젝트로 딱 만들어서 디비 들어가는 거까지만 확인할 수 있다면 어떨까?
//만약 에러가 난다면 가능성이 있는 기능의 범위가 좁기 때문에 금방 해결할 수 있다.
//따라서 테스트하는 기능은 단위를 좁게 잡을수록 좋다.
//둘째로, 그때그때 바로 할수록 좋다.
//마찬가지로 어느 기능에서 문제가 일어난 건지 명확하게 알 수 있기 때문이다.
//그리고 개발자가 개발한 지 얼마 안 됐기 때문에 기억에도 많이 남아 있는 상태이기 때문이다.
//예를 들어서 개발을 한 화면 다 끝내 놓고 한 번에 테스트한다고 해 보자.
//한 화면을 개발하기까지 시간이 걸릴 것이다.
//당연하게도 오늘 아침에 개발한 코드를 디버깅하는 게 쉬울까, 저번 달에 개발했던 코드를 디버깅하는 게 쉬울까?
//아무래도 개발한 때로부터 테스트하는 때까지의 시간적 간격이 좁을수록 테스트하기 편하다.
//테스트를 미뤄두었다가 한 번에 몰아서 하면 어디부터가 근본적인 문제인지 알기도 어렵고,
//한 번에 많은 에러가 발견되어서 의욕도 떨어진다.
//귀찮더라도 부지런하게 그때그때 테스트를 해두면서 나아가는 게 좋다.
//그때그때 바로 해두면 좋은 점이 하나 더 있다.
//개발하는 과정에서 확신을 가지고 나아갈 수가 있다.
//어디까지가 제대로 작동하는 기능인지 확실히 알고 있는 채로 개발할 수가 있다.
//한 발 한 발, 쌓아나가는 느낌으로 개발할 수가 있다.
//셋째로 자동화할수록 좋다.
//시간을 절약하기 때문이다.
//웹 화면에 가서 값을 일일이 입력하고 데이터베이스 들어가는 거까지 확인하기?
//그러다가 값을 잘못 입력했으면 다시 처음부터 해야 하나?
//테스트 과정뿐만 아니라 결과도 마찬가지다.
//우리가 지금까지 작성했던 UserDaoTest 는 main 메소드에 System.out.println() 해서 직접 콘솔에 출력했다.
//사람이 일일이 출력값을 확인하고 기대했던 값과 같은지 다른지 확인해야 했다.
//이게 한두 개라면 그럴 수 있겠지만 몇 백, 몇 천 개 면 시간이 엄청나게 들 것이다.
//
//스프링은 이렇게 중요하고 번거로울 만한 테스트 기능을 손쉽게 수행할 수 있도록 도와준다.
//테스트는 스프링이 변화에 대비하는 강력한 방법이다.
//소프트웨어에 수정 사항이 생겼을 때 투자해야 하는 시간을 훨씬 줄여준다.
//요구대로 수정하고 났더니 에러가 발생한다면..?
//또는 에러는 못 찾았지만 어딘지 모르게 불안하다면...?
//일단 서비스를 올리고 일단 운영시키고 나서야 비로소 에러를 찾을 수 있다면..?
//불안하고 찝찝하고 완성도 낮은 소프트웨어가 된다.
//반면에 테스트 코드가 있었다면 달랐을 것이다.
//수정을 마치고 나서 이미 제대로 잘 작동되던 기능들은 잘 작동되는지,
//새로 개발한 기능은 기대한 대로 작동되는지 금방 확인할 수 있다.
//자동화된 테스트만 돌려보면 되기 때문이다.
//
//자, 그럼 이렇게 중요한 테스트 기능을 스프링 프레임워크가 어떻게 지원해주는지 살펴보자.
//일단 우리가 main() 메소드를 이용해서 임시로 만들어 두었던 테스트 코드를
//스프링의 테스트 기능으로 전환하는 과정을 통해 연습해 보자.
//UserDaoTest222.class 로 가 보자.






