package basics.tobyspring4.chapter42;

import basics.tobyspring2.chapter23.User232;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

public class UserDaoJdbc42 implements UserDao42{

    private JdbcTemplate jdbcTemplate;
    private RowMapper<User232> rowMapper = new RowMapper<User232>() {
        @Override
        public User232 mapRow(ResultSet rs, int rowNum) throws SQLException {
            User232 user = new User232();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            return user;
        }
    };

    public UserDaoJdbc42() {
    }

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }


    public void deleteAll() {
        this.jdbcTemplate.update("delete from users");
    }

    public void add(User232 user) {
        this.jdbcTemplate.update("insert into users(id, name, password) values (?, ?, ?)",
                user.getId(), user.getName(), user.getPassword());
    }

    public int getCount() {
        return this.jdbcTemplate.query(
                new PreparedStatementCreator() {
                    @Override
                    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                        return con.prepareStatement("select count(*) from users");
                    }
                },
                new ResultSetExtractor<Integer>() {
                    @Override
                    public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
                        rs.next();
                        return rs.getInt(1);
                    }
                }
        );
    }

    public User232 get(String id) {
         return this.jdbcTemplate.queryForObject("select * from users where id = ?", this.rowMapper, new Object[] {id});
    }

    public List<User232> getAll() {
        return this.jdbcTemplate.query("select * from users order by id", this.rowMapper);
    }
}

//p.279 - chapter4.1
//흔히들 자바 개발자들이 예외 처리를 엄청 싫어하잖아 귀찮아 하고.
//그래서 오죽하면 예외처리를 유연하게 할 수 있는 코틀린이 너무 편하다고 할 정도.
//그럼 도대체 자바 개발자들은 왜 이렇게 예외 처리를 싫어할까?
//이게 좀 사연이 있는데.
//지금은 많이 괜찮아졌는데 예전에는 더 심했던 시절이 있어.
//그런 과정을 좀 알아야 하는데.
//예외에 대해서 좀 설명해줄게.
//
//일단 자바에서 예외라고 하면 크게 두 가지.
//하나는 에러야.
//java.lang.Error 클래스를 상속한 서브클래스들.
//에러는 주로 시스템상에 문제가 발생했을 때 사용해.
//그래서 주로 자바 VM 이 발생시키기 때문에 애플리케이션 단계에서 잡으려고 하면 안 돼.
//OutOfMemoryError 메모리가 없다거나 ThreadDeath 쓰레드가 죽었다 같은 문제인데
//이거를 애플리케이션 단계에서 아무리 잡아봐야 대응할 방법이 없기 때문이야.
//그래서 우리가 애플리케이션 구현할 때에는 특별한 작업을 하는 게 아니라면 이런 에러 처리는 신경 쓰지 않아도 돼.
//어차피 애플리케이션 계층에서는 할 수 있는 게 없으니까.
//
//자, 그럼 우리가 실제로 코딩할 때 신경 써야 하는 건 바로 '예외'
//이 예외라는 것도 크게 다시 세 가지로 나눠.
//첫째, 체크 예외 (컴파일 예외)
//둘째, 언체크 예외 (런타임 예외)
//셋째, 애플리케이션 예외 (직접 만든 예외)
//자 이 세 가지를 간단하게 하나씩 살펴보자.
//첫째로 '체크 예외'
//얘네는 Exception 클래스를 상속받은 서브클래스야.
//체크 예외가 발생할 수 있는 메소드를 사용하려면 반드시 예외 처리 코드를 함께 작성해두어야 해.
//그래서 컴파일 예외라는 말을 하는 거야.
//초기에 자바 언어와 JDK 설계자들은 체크 예외를 모든 예외에 모두 적용하려고 했어.
//생각해 봐, ArrayList 쓰면 OutOfIndexException,
//파라미터로 뭐 받아서 넣으면 NullPointerException...
//뭐만 하면 Exception 이야.
//이러니까 자바 개발자들이 예외 처리에 진절머리가 날 만하지.
//자바 개발자들이 예외 처리를 귀찮아 하는 게 바로 이런 이유야.
//근데 당연히 이건 너무 완벽주의고 비현실적이고 지나치잖아.
//그래서 굳이 예외 처리 코드를 강요하지 않는 예외들도 만들기 시작했어.
//
//둘째, '언체크 예외' 가 바로 그렇게 해서 만든 예외야.
//언체크 예외는 java.lang.RuntimeException 클래스를 상속한 서브클래스들이야.
//굳이 명시적인 예외 처리 코드를 강제하지 않지.
//또는 대표 클래스 이름을 따서 런타임 예외라고도 해.
//언체크 예외는 예외 처리 코드를 안 짜놓는 경우가 많으니까 런타임에서 Exception 나기가 쉬워.
//이걸 런타임 에러라고도 하는 이유.
//
//마지막으로 셋째, 애플리케이션 예외.
//이거는 사실 문법이나 시스템상으로 에러는 아니야.
//근데 그냥 비지니스 로직상으로 일부러 막아야 하는 경우를 말해.
//그리고 보통 체크 예외로 만들어서 예외 처리를 강제하지.
//예를 들어서, 돈을 송금하는 기능을 만들 거야.
//근데 잔액이 -3600 이면 문법적으로 문제는 없지.
//int 자료형에 음수도 들어갈 수 있으니까.
//근데 현실적으로는 그렇게 작동하면 안 되잖아.
//잔액이 없는데 송금이 되면 안 되니까.
//그래서 이런 경우는 Exception 을 일으켜버림.
//그냥 if 문으로 해도 되지 않느냐?
//물론 그렇긴 하지.
//근데 if 문으로 분기 처리 할 거면 한 번만 하고 끝나는 게 아니라
//그 뒤로도 계속 두 경우 로직을 나눠서 진행해야 하는데 지저분해지겠지.
//차라리 try/catch 로 감싸서 정상 작동하는 경우 코드를 한 쪽으로 모두 모아 놓고,
//예외 경우도 다른 한 쪽으로 모두 모아놓고, 그러는 게 보기 편하지.
//이렇게 잔액이 0원인데 송금이 안 돼야 하는 경우는 너무 중요하잖아.
//이러니까 보통 애플리케이션 예외는 체크 예외로 만들어서 예외 처리를 강제함.
//
//
//자 어떤 예외들이 있는지 종류를 하나씩 알아봤어.
//그것도 중요하지만, 그럼 이 예외들을 어떻게 처리해야 하는지 알아보자.
//예외를 어떻게 다루고 처리할지 정하려고 저걸 다 만든 거잖아.
//나는 안정적인 애플리케이션을 만들고 싶어.
//내가 만든 작품은 안정적이라고 인정받을 수 있었으면 좋겠어.
//내가 만든 결과물이라고 하면 사람들이 그냥 믿고 쓸 수 있었으면 좋겠어.
//뭐만 하면 예기치 못하게 에러 나고, 그게 아니라 어떤 경우가 발생하든 웬만하면 미리 다 준비가 돼 있는 코드.
//웬만한 경우는 다 고려하고 짠 코드라서 안정적으로 작동하는 코드.
//그런 결과물을 만드는 게 내 성격이랑도 잘 맞을 거 같아.
//평소에 개쫄보에다가 여러 경우의 수 생각하면서 계획 세우는 거 좋아하고 꼼꼼한 데다 완벽주의 같은 성격...
//이런 성격이 내가 애플리케이션 로직 짜고 예외 처리 짜놓을 때 아주 큰 장점이 될 거야.
//
//그럼 그런 안정적인 애플리케이션을 만들기 위해서는 예외를 어떻게 처리해야 하는가?
//어떻게 처리하는지 방법을 알아보기 전에, 안 좋은 예시를 먼저 살펴보자.
//'이렇게 하면 안 된다' 하는 거.
//초보 개발자뿐 아니라 실력이 쌓여도 습관적으로 저지르는 실수가 그냥 try/catch 잡아놓고 아무 처리도 안 하는 코드.
//이게 옛날에 런타임 예외가 없던 시절에 예외 처리를 강제하니까,
//뭐만 하면 무조건 예외 처리 써넣어야 하고 try/catch 문으로 범벅되던 시절,
//자바 개발자들은 습관적으로 try/catch 써놓고 아무 처리도 안 하고 넘어가고 그랬음.
//근데 이제 그게 약간 관습? 처럼 전해져 내려오면서 그런 문화가 알게 모르게 있는 듯...
//그런 탓에 진짜 처리가 필요한데도 catch 에 아무 처리도 안 하고 넘어가는 문제가 생김.
//사실 이제는 런타임 예외가 있으니 컴파일 예외는 다 처리를 해줘야 하는 게 맞음.
//catch 만 하고 안에 아무 코드도 없거나, 로그 출력만 하고 넘어가는 코드가 제일 위험해.
//왜냐하면 시한 폭탄 같은 거야.
//일단 try/catch 로 잡았으니까 애플리케이션이 뻗지는 않아.
//근데 아무 일 없다는 듯이 그냥 넘어가니까 어디서 문제인지도 찾을 수가 없어.
//아니 도대체 어느 단계, 어느 페이지만 가면 꼭 에러가 나고 오작동을 하는데 예외가 발견되지 않아.
//이거 어떻게 찾을 거야....
//이게 제일 나쁜 거야.
//예외를 스텔스 처리해버리긔...
//로그 출력했으니까 됐다?
//로그를 하루 종일 모니터링 하고 있지 않는 이상 로그는 밀려 올라가서 찾기도 어렵고 일부러 찾지 않으면 예외가 발생했었는지조차 모름.
//백퍼 일이 터지고 나서야 아는 수밖에 없게 되는 것.
//이렇게 쓸 거면 차라리 애플리케이션 뻗게 만드는 코드가 훨씬 낫다.
//catch (Exception e) { System.exit(1); }
//이렇게 해두면 그래도 어딘가에서 문제가 있고, 어디쯤만 가면 문제가 생기는구나 하는 게 보이기라도 하지.
//개발자한테 수정을 강요하기라고 하지.
//그래서 첫째로 가장 하지 말아야 하는 것, catch 잡아 놓고 아무 것도 안 하기.
//습관을 들여 놔야 해.
//정 모르겠으면 //do something 이라도 적어놓고 넘어가는 습관 들이기.
//
//그럼 에러 처리를 어떻게 하라는 거냐?
//총 세 가지 방법이 있음.
//첫째, 예외 복구.
//둘째, 예외 회피.
//셋째, 예외 전환.
//일단 가장 먼저, 첫째 '예외 복구'는 다시 애플리케이션 로직 안으로 끌어들이는 거야.
//예를 들어서 회원 가입할 때 중복된 아이디가 있어.
//그러면 DB에서 에러가 나겠지 당연히.
//그렇다고 애플리케이션 멈추게 만드는 게 아니라, "다시 입력해주세요" 띄운다든가.
//파일을 업로드 해달라고 했는데 잘못된 파일이야.
//"정상적인 파일을 업로드해주세요" 이런 식으로.
//다시 시도를 하도록 만들거나, 어딘가 페이지로 넘겨버리든가,
//우리 애플리케이션 안에서 정상 작동 흐름 안으로 다시 포함시키는 거야.
//그게 예외 복구.
//
//그 다음으로 둘째 '예외 회피' 는 내가 처리하지 않고 회피하는 거야.
//어떻게 회피하느냐?
//상위 메소드한테 떠넘겨버리고 자기는 숨음.
//자기가 어떤 메소드를 부르면서 발생할 수 있는 Exception 을 잡았는데,
//그걸 그냥 또 자기를 부르는 상위 메소드한테 throw 해버리고 자기는 회피함.
//이게 해야 할 때가 있고 하면 안 되는 때가 있어.
//해야 할 때는?
//명백하게 의도가 있을 때.
//예를 들어서, 이건 내가 처리할 게 아니다, 내 책임이 아니다, 상위에서 처리해야 할 거 같다.
//add() 메소드가 user 를 추가하는 기능인데, 똑같은 유저가 있어.
//그러면 이 user 를 add() 하려던 어떤 상위 메소드가,
//"아 똑같은 유저가 이미 있으니 다르게 입력해주세요" 라고 처리를 하겠지.
//그건 걔가 할 책임이지, add() 가 처리해야 할 책임은 아니라는 거지.
//이럴 때는 add() 입장에서는 당연히 상위로 던져주는 게 맞지.
//반면에 하면 안 되는 때는?
//그냥 생각 없이 의도도 없이 책임 떠넘기려고 할 때.
//이걸 너도 나도 다 한다고 생각해 봐.
//결국엔 어딘가에서는 이걸 다 몰아서 처리를 해야 한다는 건데, 당연히 말이 안 되지.
//메소드1 에서는 예외a,  예외b 가 발생해.
//그런데 이 각 경우에 알맞게 처리하지 않고 throw 해서 상위로 떠넘겨.
//그럼 메소드2 입장에서는 메소드1 에서 발생할 수 있는 예외a 예외b + 예외c 예외d(메소드2 안에서 쓰는 다른 메소드)
//그럼 이런 예외들을 묶어서 추상화된 예외로 처리하고,
//메소드3 에서는 에외a/예외b + 예외c/예외d  +예외e/예외f ....
//상위로 올라갈수록 예외는 점점 추상화 되고,
//하위 메소드에서 각각의 예외에 적합한 조치를 취할 수 있었던 기회가 사라짐.
//발생할 수 있는 세부적인 상황들에 걸맞게 적절한 대응을 할 수 있었지만 그 당시에 회피하고 상위로 떠넘기니까 그 기회가 점점 사라짐.
//당장 그때 그때 해야 할 일을 나중으로 미루고 상위로 미루기만 하니까 결국에는 눈덩이처럼 쌓여서 손을 댈 수가 없게 됐지.
//마치 우리 인생과도 같네...
//이제 하면 안 되는 예외 처리 두 가지 방법.
//하나는 예외를 잡아놓고 아무 처리도 하지 않는 코드.
//또 하나는 예외를 생각 없이 상위로 던지고 회피하기만 하는 코드.
//
//예외처리하는 방법 두 가지를 알아봤지.
//첫째가 예외 복구/둘째가 예외 회피/셋째가 예외 전환.
//이제 마지막 예외 전환에 대해 알아보자고.
//예외 전환은 원래 예외a 로 받았는데 예외b 로 바꿔서 다시 던져주는 거야.
//이게 뭔...?
//무슨 쓸모임?
//이렇게 생각이 들 수 있지.
//근데 들어 보면 또 그럴싸 해.
//예를 들어서 Exception 으로 체크 예외를 누가 던졌어.
//그럴 한 번 잡아서 RuntimeException 으로 포장해서 던져.
//그러면 상위 입장에서는 예외 처리를 강제당하지 않고 언체크 예외처럼 그냥 편하게 넘어가도 되지.
//요즘에 개발되는 API 들은 보통 이렇게들 많이 만들어.
//예외를 던지기는 던지는데 언체크 예외로 던짐.
//예외를 안 던지는 건 아니니까, 각 예외 경우에 맞게 처리하고 싶으면 try/catch 써도 되니까.
//예전에는 조금이라도 예외 복구할 가능성이 있는 예외라면 체크 예외로 만듦으로써 복구할 수 있는 경우를 처리하도록 강요했는데,
//요즘에는 언제나 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만들어 놓고 필요하다면 catch 블록으로 잡도록 유도함.
//예외 전환을 활용할 수 있는 상황이 하나 더 있어
//추상화하고 싶을 때.
//이걸 잘 쓰고 있는 기술이 바로 JDBC 야.
//구현할 때 인터페이스를 끼워 넣어서 결합도 낮추는 이유가 뭐야.
//수정하거나 기술이 바뀌었을 때는 대비하기 위함이지.
//예를 들어서 DB 사용을 Oracle 에서 MySql 로 바꾼다고 했을 때?
//딸려서 수정해야 하는 부분을 최소화하기 위함이지.
//그럼 생각해 보자고.
//현실적으로 DB를 바꾸는 정도 변화는 일어나기 드물겠지만,
//만약에 진짜로 DB를 바꾸어야 하는 때가 생긴다면?
//어디를 어떻게 바꿔야하지?
//add() 메소드를 보면 가장 먼저 sql 문장이 보이지.
//물론 sql 은 어느 정도 표준화돼 있는 언어이기는 해.
//하지만 각자 DB 운영사마다 조금씩 독특한 문법을 가지고 있기도 하지.
//자신만의 DB 엔진 기능을 최대화하기 위한 기술일 거야.
//아무래도 쿼리 짤 때는 이런 기술을 안 쓸 수가 없을 거야.
//그럼 DB를 바꾸게 되면 UserDao 전체를 새로 만들 수밖에 없는 건가...?
//그렇지는 않아.
//해결 방법은 sql 부분을 외부로 빼서 읽어오게끔 만드는 것.
//그 기술은 뒤에 가서 배워.
//스프링이 편리하게 알아서 다 해주지.
//그리고 또 뭘 바꿔야 하지?
//일단 UserDao 를 인터페이스로 구현해 놓았어야겠지.
//UserDao 를 인터페이스로 만들어 두고,
//구체적인 기술이 적용된 클래스는 UserDaoJdbc / UserDaoJpa / 등으로 만들기.
//그렇게 만들려고 하는데 문제가 뭐야?
//add() / get() / getAll() / getCount() / ....
//인터페이스로 추상화해야 하는데 throws 가 걸려.
//왜냐하면 DB마다 발생시키는 Exception 이 다르거든.
//똑같이 PK 가 중복되는 상황에서 DB 가 에러 코드를 넘겨 줄 때 Oracle은 1을 주고 MySql 은 1062를 주고 어떤 애는 -803을 주고...
//다 다르단 말야.
//또 DAO 를 어떤 기술로 구현했는지에 다라서도 달라.
//똑같이 PK 가 중복되는 상황에서도 JDBC 로 만든 DAO는 SQLException 을 주고,
//JPA 로 만든 DAO 는 PersistenceException 을 주고, 하이버네이트로 만든 DAO 는 HibernateException 을 준다고.
//그럼 우리가 add() 메소드를 추상화할 때는 throws 에다가 뭘 갖다 붙여야 돼?
//이러한 문제를 스프링에서는 어떻게 해결했느냐?
//바로 우리가 지금 배우는 '예외 전환'이라는 걸 이용해.
//각자 다 흩어져 있는 기술들의 Exception 들을 모아서 DataAccessException 으로 추상화해줘.
//그 안에서도 좀 더 세부적으로 InvalidDataAccessResourceUsageException 이나 TypeMismatchDataAccessException 등으로 나눠주기도 하고.
//에러 코드 같은 경우도 에러 코드 맵핑 파일을 따로 만들어서 추상화 해줌.
//예를 들어 Oracle 의 경우는
//에러코드 900/903/904/917/936/942/17006 는 모아서 badSqlGrammerCodes 로 바꿔주고,
//에러코드 1400/1722/2291/2292 는 모아서 dataIntegrityViolationCodes 로 바꿔주고...
//DB 마다 맵핑 파일을 따로 만들어서 관리해 줌.
//편하지.
// org.springframework.jdbc.support/sql-error-codes.xml
// 위 파일 보면 실제로 다 맵핑해 놓은 게 보여.
//이런 식으로 관리해준다고.
//스프링이 예외 전환을 활용하는 사례를 살펴봤어.
//기술마다 각각 다른 에러들을 하나로 포장해서 추상화해주는 역할을 했어.
//또는 체크 에러를 언체크 에러로 포장해주기도 했지.
//여기까지가 에러 처리 방법 세 번째, 에러 전환이었어.
//이렇게 해서 에러 처리 방 법 세 가지를 모두 배웠다.
//에러 복구 / 에러 회피 / 에러 전환
//
//
//
